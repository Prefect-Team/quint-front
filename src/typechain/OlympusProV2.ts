/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export interface OlympusProV2Interface extends utils.Interface {
  functions: {
    "adjustments(uint256)": FunctionFragment;
    "authority()": FunctionFragment;
    "close(uint256)": FunctionFragment;
    "create(address[2],uint256[4],bool[2],uint256[2],uint32[2])": FunctionFragment;
    "currentControlVariable(uint256)": FunctionFragment;
    "currentDebt(uint256)": FunctionFragment;
    "daoReward()": FunctionFragment;
    "deposit(uint48,uint256[2],address[2])": FunctionFragment;
    "disableRewards(bool)": FunctionFragment;
    "enableRewards()": FunctionFragment;
    "findMarketFor(address,address,uint256,uint256,uint256)": FunctionFragment;
    "getReward(address[])": FunctionFragment;
    "indexesFor(address)": FunctionFragment;
    "instantSwap(uint256)": FunctionFragment;
    "isLive(uint256)": FunctionFragment;
    "liveMarkets()": FunctionFragment;
    "liveMarketsBetween(uint256,uint256)": FunctionFragment;
    "liveMarketsFor(bool,bool,address)": FunctionFragment;
    "marketPrice(uint256)": FunctionFragment;
    "markets(uint256)": FunctionFragment;
    "marketsFor(address,address)": FunctionFragment;
    "marketsForBase(address,uint256)": FunctionFragment;
    "marketsForCreator(address,uint256)": FunctionFragment;
    "marketsForQuote(address,uint256)": FunctionFragment;
    "maxIn(uint256)": FunctionFragment;
    "metadata(uint256)": FunctionFragment;
    "notes(address,uint256)": FunctionFragment;
    "payoutFor(uint256,uint256)": FunctionFragment;
    "pendingFor(address,uint256)": FunctionFragment;
    "pullNote(address,uint256)": FunctionFragment;
    "pushNote(address,uint256)": FunctionFragment;
    "redeem(address,uint256[])": FunctionFragment;
    "redeemAll(address)": FunctionFragment;
    "refReward()": FunctionFragment;
    "rewards(address,address)": FunctionFragment;
    "setAuthority(address)": FunctionFragment;
    "terms(uint256)": FunctionFragment;
    "vestingContract()": FunctionFragment;
    "whitelist(address)": FunctionFragment;
    "whitelisted(address)": FunctionFragment;
  };

  encodeFunctionData(functionFragment: "adjustments", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "authority", values?: undefined): string;
  encodeFunctionData(functionFragment: "close", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "create",
    values: [
      [string, string],
      [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      [boolean, boolean],
      [BigNumberish, BigNumberish],
      [BigNumberish, BigNumberish],
    ],
  ): string;
  encodeFunctionData(functionFragment: "currentControlVariable", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "currentDebt", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "daoReward", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [BigNumberish, [BigNumberish, BigNumberish], [string, string]],
  ): string;
  encodeFunctionData(functionFragment: "disableRewards", values: [boolean]): string;
  encodeFunctionData(functionFragment: "enableRewards", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "findMarketFor",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish],
  ): string;
  encodeFunctionData(functionFragment: "getReward", values: [string[]]): string;
  encodeFunctionData(functionFragment: "indexesFor", values: [string]): string;
  encodeFunctionData(functionFragment: "instantSwap", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "isLive", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "liveMarkets", values?: undefined): string;
  encodeFunctionData(functionFragment: "liveMarketsBetween", values: [BigNumberish, BigNumberish]): string;
  encodeFunctionData(functionFragment: "liveMarketsFor", values: [boolean, boolean, string]): string;
  encodeFunctionData(functionFragment: "marketPrice", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "markets", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "marketsFor", values: [string, string]): string;
  encodeFunctionData(functionFragment: "marketsForBase", values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: "marketsForCreator", values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: "marketsForQuote", values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: "maxIn", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "metadata", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "notes", values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: "payoutFor", values: [BigNumberish, BigNumberish]): string;
  encodeFunctionData(functionFragment: "pendingFor", values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: "pullNote", values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: "pushNote", values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: "redeem", values: [string, BigNumberish[]]): string;
  encodeFunctionData(functionFragment: "redeemAll", values: [string]): string;
  encodeFunctionData(functionFragment: "refReward", values?: undefined): string;
  encodeFunctionData(functionFragment: "rewards", values: [string, string]): string;
  encodeFunctionData(functionFragment: "setAuthority", values: [string]): string;
  encodeFunctionData(functionFragment: "terms", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "vestingContract", values?: undefined): string;
  encodeFunctionData(functionFragment: "whitelist", values: [string]): string;
  encodeFunctionData(functionFragment: "whitelisted", values: [string]): string;

  decodeFunctionResult(functionFragment: "adjustments", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "authority", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "close", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "currentControlVariable", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "currentDebt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "daoReward", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "disableRewards", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "enableRewards", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "findMarketFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getReward", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "indexesFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "instantSwap", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isLive", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liveMarkets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liveMarketsBetween", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liveMarketsFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "marketPrice", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "markets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "marketsFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "marketsForBase", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "marketsForCreator", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "marketsForQuote", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "maxIn", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "metadata", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "notes", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "payoutFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pendingFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pullNote", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pushNote", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "redeem", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "redeemAll", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "refReward", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "rewards", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setAuthority", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "terms", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "vestingContract", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "whitelist", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "whitelisted", data: BytesLike): Result;

  events: {
    "AuthorityUpdated(address)": EventFragment;
    "Bond(uint256,uint256,uint256)": EventFragment;
    "CloseMarket(uint256)": EventFragment;
    "CreateMarket(uint256,address,address,uint256,uint256)": EventFragment;
    "Tuned(uint256,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AuthorityUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Bond"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CloseMarket"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreateMarket"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Tuned"): EventFragment;
}

export type AuthorityUpdatedEvent = TypedEvent<[string], { authority: string }>;

export type AuthorityUpdatedEventFilter = TypedEventFilter<AuthorityUpdatedEvent>;

export type BondEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  { id: BigNumber; amount: BigNumber; price: BigNumber }
>;

export type BondEventFilter = TypedEventFilter<BondEvent>;

export type CloseMarketEvent = TypedEvent<[BigNumber], { id: BigNumber }>;

export type CloseMarketEventFilter = TypedEventFilter<CloseMarketEvent>;

export type CreateMarketEvent = TypedEvent<
  [BigNumber, string, string, BigNumber, BigNumber],
  {
    id: BigNumber;
    baseToken: string;
    quoteToken: string;
    initialPrice: BigNumber;
    conclusion: BigNumber;
  }
>;

export type CreateMarketEventFilter = TypedEventFilter<CreateMarketEvent>;

export type TunedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  {
    id: BigNumber;
    oldControlVariable: BigNumber;
    newControlVariable: BigNumber;
  }
>;

export type TunedEventFilter = TypedEventFilter<TunedEvent>;

export interface OlympusProV2 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: OlympusProV2Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    adjustments(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, number, boolean] & {
        change: BigNumber;
        lastAdjustment: number;
        timeToAdjusted: number;
        active: boolean;
      }
    >;

    authority(overrides?: CallOverrides): Promise<[string]>;

    close(_id: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    create(
      _tokens: [string, string],
      _market: [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      _booleans: [boolean, boolean],
      _terms: [BigNumberish, BigNumberish],
      _intervals: [BigNumberish, BigNumberish],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    currentControlVariable(_id: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    currentDebt(_id: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    daoReward(overrides?: CallOverrides): Promise<[BigNumber]>;

    deposit(
      _id: BigNumberish,
      _amounts: [BigNumberish, BigNumberish],
      _addresses: [string, string],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    disableRewards(
      _dao: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    enableRewards(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    findMarketFor(
      tokenIn: string,
      tokenOut: string,
      amountIn: BigNumberish,
      minAmountOut: BigNumberish,
      maxExpiry: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { id: BigNumber }>;

    getReward(
      tokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    indexesFor(_user: string, overrides?: CallOverrides): Promise<[BigNumber[]] & { indexes_: BigNumber[] }>;

    instantSwap(_id: BigNumberish, overrides?: CallOverrides): Promise<[boolean]>;

    isLive(_id: BigNumberish, overrides?: CallOverrides): Promise<[boolean]>;

    liveMarkets(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    liveMarketsBetween(
      firstIndex: BigNumberish,
      lastIndex: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber[]]>;

    liveMarketsFor(
      _creator: boolean,
      _base: boolean,
      _address: string,
      overrides?: CallOverrides,
    ): Promise<[BigNumber[]]>;

    marketPrice(_id: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    markets(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [string, string, string, boolean, boolean, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        creator: string;
        baseToken: string;
        quoteToken: string;
        call: boolean;
        capacityInQuote: boolean;
        capacity: BigNumber;
        totalDebt: BigNumber;
        minPrice: BigNumber;
        maxPayout: BigNumber;
        sold: BigNumber;
        purchased: BigNumber;
      }
    >;

    marketsFor(tokenIn: string, tokenOut: string, overrides?: CallOverrides): Promise<[BigNumber[]]>;

    marketsForBase(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    marketsForCreator(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    marketsForQuote(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    maxIn(_id: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    metadata(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [number, number, number, number, number, number, number] & {
        lastTune: number;
        lastDecay: number;
        length: number;
        depositInterval: number;
        tuneInterval: number;
        baseDecimals: number;
        quoteDecimals: number;
      }
    >;

    notes(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, number, number, number, string] & {
        payout: BigNumber;
        created: number;
        matured: number;
        redeemed: number;
        marketID: number;
        token: string;
      }
    >;

    payoutFor(_amount: BigNumberish, _id: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    pendingFor(
      _user: string,
      _index: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, boolean] & { payout_: BigNumber; matured_: boolean }>;

    pullNote(
      _from: string,
      _index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    pushNote(
      _to: string,
      _index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    redeem(
      _user: string,
      _indexes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    redeemAll(_user: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    refReward(overrides?: CallOverrides): Promise<[BigNumber]>;

    rewards(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    setAuthority(
      _newAuthority: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    terms(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, boolean, number, number] & {
        controlVariable: BigNumber;
        maxDebt: BigNumber;
        fixedTerm: boolean;
        vesting: number;
        conclusion: number;
      }
    >;

    vestingContract(overrides?: CallOverrides): Promise<[string]>;

    whitelist(
      _operator: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    whitelisted(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;
  };

  adjustments(
    arg0: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, number, number, boolean] & {
      change: BigNumber;
      lastAdjustment: number;
      timeToAdjusted: number;
      active: boolean;
    }
  >;

  authority(overrides?: CallOverrides): Promise<string>;

  close(_id: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  create(
    _tokens: [string, string],
    _market: [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
    _booleans: [boolean, boolean],
    _terms: [BigNumberish, BigNumberish],
    _intervals: [BigNumberish, BigNumberish],
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  currentControlVariable(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  currentDebt(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  daoReward(overrides?: CallOverrides): Promise<BigNumber>;

  deposit(
    _id: BigNumberish,
    _amounts: [BigNumberish, BigNumberish],
    _addresses: [string, string],
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  disableRewards(
    _dao: boolean,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  enableRewards(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  findMarketFor(
    tokenIn: string,
    tokenOut: string,
    amountIn: BigNumberish,
    minAmountOut: BigNumberish,
    maxExpiry: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getReward(
    tokens: string[],
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  indexesFor(_user: string, overrides?: CallOverrides): Promise<BigNumber[]>;

  instantSwap(_id: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

  isLive(_id: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

  liveMarkets(overrides?: CallOverrides): Promise<BigNumber[]>;

  liveMarketsBetween(
    firstIndex: BigNumberish,
    lastIndex: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<BigNumber[]>;

  liveMarketsFor(_creator: boolean, _base: boolean, _address: string, overrides?: CallOverrides): Promise<BigNumber[]>;

  marketPrice(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  markets(
    arg0: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<
    [string, string, string, boolean, boolean, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      creator: string;
      baseToken: string;
      quoteToken: string;
      call: boolean;
      capacityInQuote: boolean;
      capacity: BigNumber;
      totalDebt: BigNumber;
      minPrice: BigNumber;
      maxPayout: BigNumber;
      sold: BigNumber;
      purchased: BigNumber;
    }
  >;

  marketsFor(tokenIn: string, tokenOut: string, overrides?: CallOverrides): Promise<BigNumber[]>;

  marketsForBase(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  marketsForCreator(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  marketsForQuote(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  maxIn(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  metadata(
    arg0: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<
    [number, number, number, number, number, number, number] & {
      lastTune: number;
      lastDecay: number;
      length: number;
      depositInterval: number;
      tuneInterval: number;
      baseDecimals: number;
      quoteDecimals: number;
    }
  >;

  notes(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, number, number, number, number, string] & {
      payout: BigNumber;
      created: number;
      matured: number;
      redeemed: number;
      marketID: number;
      token: string;
    }
  >;

  payoutFor(_amount: BigNumberish, _id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  pendingFor(
    _user: string,
    _index: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, boolean] & { payout_: BigNumber; matured_: boolean }>;

  pullNote(
    _from: string,
    _index: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  pushNote(
    _to: string,
    _index: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  redeem(
    _user: string,
    _indexes: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  redeemAll(_user: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  refReward(overrides?: CallOverrides): Promise<BigNumber>;

  rewards(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

  setAuthority(
    _newAuthority: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  terms(
    arg0: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, boolean, number, number] & {
      controlVariable: BigNumber;
      maxDebt: BigNumber;
      fixedTerm: boolean;
      vesting: number;
      conclusion: number;
    }
  >;

  vestingContract(overrides?: CallOverrides): Promise<string>;

  whitelist(
    _operator: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  whitelisted(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  callStatic: {
    adjustments(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, number, boolean] & {
        change: BigNumber;
        lastAdjustment: number;
        timeToAdjusted: number;
        active: boolean;
      }
    >;

    authority(overrides?: CallOverrides): Promise<string>;

    close(_id: BigNumberish, overrides?: CallOverrides): Promise<void>;

    create(
      _tokens: [string, string],
      _market: [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      _booleans: [boolean, boolean],
      _terms: [BigNumberish, BigNumberish],
      _intervals: [BigNumberish, BigNumberish],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    currentControlVariable(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    currentDebt(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    daoReward(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      _id: BigNumberish,
      _amounts: [BigNumberish, BigNumberish],
      _addresses: [string, string],
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        payout_: BigNumber;
        expiry_: BigNumber;
        index_: BigNumber;
      }
    >;

    disableRewards(_dao: boolean, overrides?: CallOverrides): Promise<void>;

    enableRewards(overrides?: CallOverrides): Promise<void>;

    findMarketFor(
      tokenIn: string,
      tokenOut: string,
      amountIn: BigNumberish,
      minAmountOut: BigNumberish,
      maxExpiry: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getReward(tokens: string[], overrides?: CallOverrides): Promise<void>;

    indexesFor(_user: string, overrides?: CallOverrides): Promise<BigNumber[]>;

    instantSwap(_id: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

    isLive(_id: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

    liveMarkets(overrides?: CallOverrides): Promise<BigNumber[]>;

    liveMarketsBetween(
      firstIndex: BigNumberish,
      lastIndex: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber[]>;

    liveMarketsFor(
      _creator: boolean,
      _base: boolean,
      _address: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber[]>;

    marketPrice(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    markets(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [string, string, string, boolean, boolean, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        creator: string;
        baseToken: string;
        quoteToken: string;
        call: boolean;
        capacityInQuote: boolean;
        capacity: BigNumber;
        totalDebt: BigNumber;
        minPrice: BigNumber;
        maxPayout: BigNumber;
        sold: BigNumber;
        purchased: BigNumber;
      }
    >;

    marketsFor(tokenIn: string, tokenOut: string, overrides?: CallOverrides): Promise<BigNumber[]>;

    marketsForBase(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    marketsForCreator(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    marketsForQuote(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    maxIn(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    metadata(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [number, number, number, number, number, number, number] & {
        lastTune: number;
        lastDecay: number;
        length: number;
        depositInterval: number;
        tuneInterval: number;
        baseDecimals: number;
        quoteDecimals: number;
      }
    >;

    notes(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, number, number, number, string] & {
        payout: BigNumber;
        created: number;
        matured: number;
        redeemed: number;
        marketID: number;
        token: string;
      }
    >;

    payoutFor(_amount: BigNumberish, _id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    pendingFor(
      _user: string,
      _index: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, boolean] & { payout_: BigNumber; matured_: boolean }>;

    pullNote(_from: string, _index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    pushNote(_to: string, _index: BigNumberish, overrides?: CallOverrides): Promise<void>;

    redeem(_user: string, _indexes: BigNumberish[], overrides?: CallOverrides): Promise<void>;

    redeemAll(_user: string, overrides?: CallOverrides): Promise<void>;

    refReward(overrides?: CallOverrides): Promise<BigNumber>;

    rewards(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(_newAuthority: string, overrides?: CallOverrides): Promise<void>;

    terms(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, boolean, number, number] & {
        controlVariable: BigNumber;
        maxDebt: BigNumber;
        fixedTerm: boolean;
        vesting: number;
        conclusion: number;
      }
    >;

    vestingContract(overrides?: CallOverrides): Promise<string>;

    whitelist(_operator: string, overrides?: CallOverrides): Promise<void>;

    whitelisted(arg0: string, overrides?: CallOverrides): Promise<boolean>;
  };

  filters: {
    "AuthorityUpdated(address)"(authority?: string | null): AuthorityUpdatedEventFilter;
    AuthorityUpdated(authority?: string | null): AuthorityUpdatedEventFilter;

    "Bond(uint256,uint256,uint256)"(id?: BigNumberish | null, amount?: null, price?: null): BondEventFilter;
    Bond(id?: BigNumberish | null, amount?: null, price?: null): BondEventFilter;

    "CloseMarket(uint256)"(id?: BigNumberish | null): CloseMarketEventFilter;
    CloseMarket(id?: BigNumberish | null): CloseMarketEventFilter;

    "CreateMarket(uint256,address,address,uint256,uint256)"(
      id?: BigNumberish | null,
      baseToken?: null,
      quoteToken?: null,
      initialPrice?: null,
      conclusion?: null,
    ): CreateMarketEventFilter;
    CreateMarket(
      id?: BigNumberish | null,
      baseToken?: null,
      quoteToken?: null,
      initialPrice?: null,
      conclusion?: null,
    ): CreateMarketEventFilter;

    "Tuned(uint256,uint256,uint256)"(
      id?: BigNumberish | null,
      oldControlVariable?: null,
      newControlVariable?: null,
    ): TunedEventFilter;
    Tuned(id?: BigNumberish | null, oldControlVariable?: null, newControlVariable?: null): TunedEventFilter;
  };

  estimateGas: {
    adjustments(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    authority(overrides?: CallOverrides): Promise<BigNumber>;

    close(_id: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    create(
      _tokens: [string, string],
      _market: [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      _booleans: [boolean, boolean],
      _terms: [BigNumberish, BigNumberish],
      _intervals: [BigNumberish, BigNumberish],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    currentControlVariable(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    currentDebt(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    daoReward(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      _id: BigNumberish,
      _amounts: [BigNumberish, BigNumberish],
      _addresses: [string, string],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    disableRewards(_dao: boolean, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    enableRewards(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    findMarketFor(
      tokenIn: string,
      tokenOut: string,
      amountIn: BigNumberish,
      minAmountOut: BigNumberish,
      maxExpiry: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getReward(tokens: string[], overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    indexesFor(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

    instantSwap(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    isLive(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    liveMarkets(overrides?: CallOverrides): Promise<BigNumber>;

    liveMarketsBetween(
      firstIndex: BigNumberish,
      lastIndex: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    liveMarketsFor(_creator: boolean, _base: boolean, _address: string, overrides?: CallOverrides): Promise<BigNumber>;

    marketPrice(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    markets(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    marketsFor(tokenIn: string, tokenOut: string, overrides?: CallOverrides): Promise<BigNumber>;

    marketsForBase(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    marketsForCreator(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    marketsForQuote(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    maxIn(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    metadata(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    notes(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    payoutFor(_amount: BigNumberish, _id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    pendingFor(_user: string, _index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    pullNote(
      _from: string,
      _index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    pushNote(
      _to: string,
      _index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    redeem(
      _user: string,
      _indexes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    redeemAll(_user: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    refReward(overrides?: CallOverrides): Promise<BigNumber>;

    rewards(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(
      _newAuthority: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    terms(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    vestingContract(overrides?: CallOverrides): Promise<BigNumber>;

    whitelist(_operator: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    whitelisted(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    adjustments(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    close(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    create(
      _tokens: [string, string],
      _market: [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      _booleans: [boolean, boolean],
      _terms: [BigNumberish, BigNumberish],
      _intervals: [BigNumberish, BigNumberish],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    currentControlVariable(_id: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    currentDebt(_id: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    daoReward(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      _id: BigNumberish,
      _amounts: [BigNumberish, BigNumberish],
      _addresses: [string, string],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    disableRewards(
      _dao: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    enableRewards(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    findMarketFor(
      tokenIn: string,
      tokenOut: string,
      amountIn: BigNumberish,
      minAmountOut: BigNumberish,
      maxExpiry: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getReward(
      tokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    indexesFor(_user: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    instantSwap(_id: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isLive(_id: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liveMarkets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liveMarketsBetween(
      firstIndex: BigNumberish,
      lastIndex: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    liveMarketsFor(
      _creator: boolean,
      _base: boolean,
      _address: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    marketPrice(_id: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    markets(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketsFor(tokenIn: string, tokenOut: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketsForBase(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketsForCreator(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketsForQuote(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxIn(_id: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    metadata(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    notes(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    payoutFor(_amount: BigNumberish, _id: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingFor(_user: string, _index: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pullNote(
      _from: string,
      _index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    pushNote(
      _to: string,
      _index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    redeem(
      _user: string,
      _indexes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    redeemAll(
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    refReward(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewards(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuthority(
      _newAuthority: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    terms(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    vestingContract(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    whitelist(
      _operator: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    whitelisted(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
